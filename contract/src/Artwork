// // SPDX-License-Identifier: MIT
// pragma solidity ^0.8.19;

// /**
//  * ArtGallery.sol
//  *
//  * - Multi-edition artworks implemented using ERC1155
//  * - Artists create artworks (title, price, quantity, category, uri)
//  * - Contract mints initial quantity into the contract (marketplace stock)
//  * - Buyers purchase (payable) and receive tokens
//  * - Artists can update and soft-delete their artwork
//  * - Artists can withdraw proceeds
//  */

// // This extension adds tracking for the total supply of each token ID
// // (how many have been minted and burned).
// // It also provides helper functions like `totalSupply(id)` and `exists(id)`.
// // Very useful when you want to know how many editions of an artwork exist.
// import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol";
// import "@openzeppelin/contracts/access/Ownable.sol";
// // It provides a safe and clean way to handle counters that can increment, decrement, or reset.
// // Useful for auto-incrementing IDs (like artwork IDs) without manual bookkeeping.
// import "@openzeppelin/contracts/utils/Counters.sol";
// // import "@openzeppelin/contracts/utils/C";

// contract ArtGallery is ERC1155Supply, Ownable {
//     using Counters for Counters.Counter;
//     Counters.Counter private _artworkIdCounter;

//     struct Artwork {
//         uint256 id;
//         address creator;
//         string title;
//         string category;
//         string uri; // metadata URI for the token id
//         uint256 priceWei; // price per edition in wei
//         uint256 totalQuantity; // total minted editions
//         uint256 available; // stock currently held by marketplace (contract)
//         bool deleted; // soft delete
//         uint256 createdAt;
//         uint256 updatedAt;
//     }

//     // id -> Artwork
//     mapping(uint256 => Artwork) private artworks;
//     // creator => withdrawable balance
//     mapping(address => uint256) public proceeds;

//     // events
//     event ArtworkCreated(
//         uint256 indexed id,
//         address indexed creator,
//         string title,
//         uint256 priceWei,
//         uint256 quantity
//     );
//     event ArtworkUpdated(uint256 indexed id, address indexed creator);
//     event ArtworkDeleted(uint256 indexed id, address indexed creator);
//     event ArtworkBought(
//         uint256 indexed id,
//         address indexed buyer,
//         uint256 amount,
//         uint256 totalPrice
//     );
//     event ProceedsWithdrawn(address indexed artist, uint256 amount);

//     constructor(string memory defaultURI) ERC1155(defaultURI) {}

//     modifier onlyCreator(uint256 id) {
//         require(artworks[id].creator == msg.sender, "Not the artwork creator");
//         _;
//     }

//     modifier exists(uint256 id) {
//         require(artworks[id].creator != address(0), "Artwork does not exist");
//         _;
//     }

//     /**
//      * Create new artwork.
//      * Mints `quantity` of token id to the contract itself (marketplace stock).
//      */
//     function createArtwork(
//         string calldata _uri,
//         string calldata _title,
//         string calldata _category,
//         uint256 _priceWei,
//         uint256 _quantity
//     ) external returns (uint256) {
//         require(_quantity > 0, "Quantity must be > 0");
//         require(_priceWei > 0, "Price must be > 0");

//         _artworkIdCounter.increment();
//         uint256 newId = _artworkIdCounter.current();

//         artworks[newId] = Artwork({
//             id: newId,
//             creator: msg.sender,
//             title: _title,
//             category: _category,
//             uri: _uri,
//             priceWei: _priceWei,
//             totalQuantity: _quantity,
//             available: _quantity,
//             deleted: false,
//             createdAt: block.timestamp,
//             updatedAt: block.timestamp
//         });

//         // mint editions to the contract to act as marketplace stock
//         _mint(address(this), newId, _quantity, "");
//         // set uri for this token id
//         _setURIForToken(newId, _uri);

//         emit ArtworkCreated(newId, msg.sender, _title, _priceWei, _quantity);
//         return newId;
//     }
//     function buyArtwork(
//         uint256 id,
//         uint256 amount
//     ) external payable exists(id) {
//         require(amount > 0, "Amount must be > 0");
//         Artwork storage a = artworks[id];
//         require(!a.deleted, "Artwork deleted");
//         require(a.available >= amount, "Not enough available stock");

//         uint256 totalPrice = a.priceWei * amount;
//         require(msg.value == totalPrice, "Incorrect ETH sent");

//         // decrement available stock
//         a.available -= amount;

//         // transfer the token(s) from contract to buyer
//         // contract must be approved / safeTransferFrom from itself is fine here
//         _safeTransferFrom(address(this), msg.sender, id, amount, "");

//         // record proceeds for artist
//         proceeds[a.creator] += msg.value;

//         emit ArtworkBought(id, msg.sender, amount, totalPrice);
//     }
//     function getArtwork(
//         uint256 id
//     ) external view exists(id) returns (Artwork memory) {
//         return artworks[id];
//     }
//     receive() external payable {}
// }
